using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceInject
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            const string attribute = @"// <auto-generated />
using Microsoft.Extensions.DependencyInjection;
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal class InjectAttribute : System.Attribute
{
    internal InjectAttribute(ServiceLifetime serviceLifetime = ServiceLifetime.Transient) { }
}
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal class InjectSingletonAttribute : System.Attribute
{
}
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal class InjectScopedAttribute : System.Attribute
{
}
[System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal class InjectTransientAttribute : System.Attribute
{
}
";
            context.RegisterForPostInitialization(context => context.AddSource("Inject.Generated.cs", SourceText.From(attribute, Encoding.UTF8)));
            context.RegisterForSyntaxNotifications(() => new ServicesReceiver());
        }

        private static Lifetime GetLifetime(IImmutableList<AttributeData> attributes)
        {
            if (attributes.Any(a => a.AttributeClass?.Name == "InjectSingletonAttribute"))
                return Lifetime.Singleton;
            if (attributes.Any(a => a.AttributeClass?.Name == "InjectScopedAttribute"))
                return Lifetime.Scoped;
            if (attributes.Any(a => a.AttributeClass?.Name == "InjectTransientAttribute"))
                return Lifetime.Transient;
            var injectAttribute = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "InjectAttribute");
            if (injectAttribute == null)
                return Lifetime.None;
            var injectArg = injectAttribute.ConstructorArguments.FirstOrDefault();
            if (injectArg.IsNull || injectArg.Kind != TypedConstantKind.Enum || injectArg.Type?.ToString() != "Microsoft.Extensions.DependencyInjection.ServiceLifetime")
                return Lifetime.None;
            switch (injectArg.Value)
            {
                case 1: // scoped
                    return Lifetime.Scoped;
                case 2: // transient
                    return Lifetime.Transient;
                default: // 0 (singleton) or others
                    return Lifetime.Singleton;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var receiver = (ServicesReceiver?)context.SyntaxReceiver;
            if (receiver == null || !receiver.ClassesToRegister.Any() || !receiver.HasCallToMethod)
                return;
            var registrations = new StringBuilder();
            const string spaces = "            ";
            foreach (var clazz in receiver.ClassesToRegister)
            {
                var semanticModel = context.Compilation.GetSemanticModel(clazz.SyntaxTree);
                if (semanticModel == null)
                    continue;
                var symbol = semanticModel.GetDeclaredSymbol(clazz);
                if (symbol == null)
                    return;
                var lifetime = GetLifetime(symbol.GetAttributes());
                switch (lifetime)
                {
                    case Lifetime.Singleton:
                        registrations.Append(spaces);
                        registrations.AppendLine($"services.AddSingleton<{GetFullName(symbol)}>();");
                        break;
                    case Lifetime.Scoped:
                        registrations.Append(spaces);
                        registrations.AppendLine($"services.AddScoped<{GetFullName(symbol)}>();");
                        break;
                    case Lifetime.Transient:
                        registrations.Append(spaces);
                        registrations.AppendLine($"services.AddTransient<{GetFullName(symbol)}>();");
                        break;
                    default:
                        break;
                }
            }

            var invocationSemanticModel = context.Compilation.GetSemanticModel(receiver.InvocationSyntaxNode.SyntaxTree);
            var methodSyntax = receiver.InvocationSyntaxNode.FirstAncestorOrSelf<MethodDeclarationSyntax>();
            var methodSymbol = methodSyntax == null ? null : invocationSemanticModel.GetDeclaredSymbol(methodSyntax);
            var code = $@"    public static class GeneratedServicesExtension
    {{
        public static void Discover(this IServiceCollection services)
        {{
{registrations}        }}
    }}";
            if (methodSymbol == null || methodSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                var newClassCodeBuilder = new StringBuilder();
                foreach (var line in code.Split(new[] { @"
" }, StringSplitOptions.None))
                {
                    if (line.Length > 4 && line.Substring(0, 4) == "    ")
                        newClassCodeBuilder.AppendLine(line.Substring(4, line.Length - 4));
                    else
                        newClassCodeBuilder.AppendLine(line);
                }
                code = newClassCodeBuilder.ToString();
            }
            else
            {
                var ns = methodSymbol.ContainingNamespace.Name.ToString();
                code = $@"namespace {ns}
{{
{code}
}}
";
            }
            code = @"// <auto-generated />
using Microsoft.Extensions.DependencyInjection;

" + code;
            context.AddSource("GeneratedServicesExtension.Generated.cs", SourceText.From(code, Encoding.UTF8));
        }

        public static string GetFullName(ISymbol symbol)
        {
            var ns = symbol.ContainingNamespace;
            var nss = new List<string>();
            while (ns != null)
            {
                if (string.IsNullOrWhiteSpace(ns.Name))
                    break;
                nss.Add(ns.Name);
                ns = ns.ContainingNamespace;
            }
            nss.Reverse();
            if (nss.Any())
                return $"{string.Join(".", nss)}.{symbol.Name}";
            return symbol.Name;
        }

        enum Lifetime
        {
            None, Singleton, Scoped, Transient
        }
    }
}


